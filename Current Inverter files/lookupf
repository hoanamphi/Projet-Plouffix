#! /usr/local/bin/perl5#######################################################################  The Lookup Script#  -----------------#  This script takes a value from a form the type of lookup,#  and does a search for that number in the list of constants.##  Ver 0.1  -- Written by Adam Van Tuyl, for the ISC, Summer of 1995#  Ver 1.0  -- Rewritten 06/04/96, Paul Irvine -- genexp, intrel added#  Ver 2.0  -- Updated 09/06/96, Paul Irvine -- new interface, maple, browser#  Ver 3.0  -- Updated 01/30/96, Paul Irvine -- integers, filtering, perl5#  Ver 3.14 -- Arrangee par Simon Plouffe pour l'Inverseur de Plouffe, 2 mars 1998.#              on garde seulement le lookup et le browse + quelques fonctions#              et AUCUN maple...#  Notes:#  * Program split into five main subroutines, one for each of the #     various functions.  Specific notes for the various subroutines#     will be found directly before the routine.#  * This piece takes the input from the form, and then sends#     the needed information to one of the specific lookups######################################################################use integer;require "/opt/etc/httpd/cgi-bin/PIlook.pl";require "/opt/etc/httpd/cgi-bin/CGI_lib.pl";$version = "3.1415";$root= "http://www.lacim.uqam.ca/cgi-bin/lookupf";&ReadParse();## unbuffer STDOUT$|++;#### get information from the forms$xx = $in{'number'};$type = $in{'lookup_type'};$page = $in{'page_no'};$title = &title_string($type, $xx, $page);#### Load the rindex and iindex arraysopen (RIND, "/plouffe/IP/rindex") || die "Couldn't open rindex: $?";while (<RIND>) {  $temp = $_;  $rindex{substr($temp, 0, 4)} = substr($temp, 5);}close (RIND);open (RIND, "/plouffe/IP/indexN") || die "Couldn't open iindex: $?";while (<RIND>) {  $temp = $_;  $iindex{substr($temp, 0, 4)} = substr($temp, 5);}close (RIND);&PImain();sub PImain {#### prepare the web pageprint "Content-type: text/html\n\n";print <<EOF;<HTML><HEAD><TITLE>$title</TITLE>EOFprint <<EOF;</HEAD><BODY BGCOLOR=FFFFFF  LINK=FF0000 VLINK=990000><CENTER><IMG SRC = /pi/pideyves.gif ALT = "[Inverseur de Plouffe]"><DT><B><FONT SIZE="+4" COLOR="#AF0000">Inverseur de Plouffe</A></FONT></B></CENTER>EOFprint <<EOF;<HR SIZE = 3><H2>R&eacute;sultat de la recherche...:</H2><PRE>EOF#### determine which lookup should be performed#if (&is_float($xx) == 0) {#  if (&is_passable($xx)) {#    print "</PRE><HR SIZE = 3><PRE>";#  } else {#    print "</PRE><B>Seulement des nombres sont accep&eacute;s... essayez encore.\n<PRE>";#    &endoc;#  }#}if ($type eq "browse") {  &browse($xx, $page);} elsif ($type eq "simple") {  &simple_look($xx);} else {  print "Valeur iil&eacute;gale\n";  print "C'&eacute;tait $type.\n";  &endoc;}print "</BODY></HTML>";}exit (0);#######################################################################  The "Browse" Lookup Subroutine#  This subroutine takes the input and checks to see if it is in #  one of the files of constants.  It returns a general description#  of that number (if it finds a match) and gives the specific#  function that could have produced the input.##  Notes:#  * To change the number of returns the program allows, change#  the variable $returns, found below######################################################################sub browse {  my($x, $page_no) = @_;  my($returns) = 100;  my($len);  my(@index);  my($before) = 1;  my($integer) = 0;  my($oneless) = int($page_no - 1);  my($onemore) = int($page_no + 1);  my($prefix) = "$root?lookup_type=browse&page_no=";  my($back) = "onMouseOver=\"window.status='Fureter en arri&egrave;re'; return true\"";  my($forward) = "onMouseOver=\"window.status='Fureter en avant'; return true\"";#### Verify and clean input  $x = &clean_input($x);  &verify($x);  if (index($x, ".") == -1) {      $integer = 1;      $cc = $x;      &verify_length($cc, 4);  } else {      $cc = &remove_decimal($x);      $cc = &clean_input($cc);      $cc = substr($cc, 0, 16);      &rational_check($cc);      &verify_length($cc, 5);  }#### Look up entries and put into command buffer  if ($integer) {      $len = length($cc) - 3;      @index = &browsePIn($cc, $returns / 2, $page_no, $in{'top'}, $in{'bottom'});  } else {      $len = 13;      @index = &browsePI($cc, $returns / 2, $page_no, $in{'top'}, $in{'bottom'});  }  &write_log("browse", $x, "page $page_no");#### Begin writing the HTML output file  print "Feuilletage $x:\n\n";  print "Nombre"." " x $len."Table  Expression\n\n";  print "<A HREF=$prefix$oneless&number=$x $back>[en arri&egrave;re]</A>\n";  for (@index)  {    ($value, $rcode, $descr) = @$_;    if ($value =~ /^$cc/) {      $before = 0;      print "<FONT COLOR=D000D0><B>".            substr($value,0,length($cc))."</B></FONT>".            substr($value,length($cc))." = ($rcode) $descr\n";    } else {      if ($before && $page_no == 0 && $cc lt $value) {        $before = 0;        print "<FONT COLOR=D000D0><B>Votre nombre $cc serait ici.</B></FONT>\n";      }      print "$value = ($rcode) $descr\n";    }  }  print "<A HREF=$prefix$onemore&number=$x $forward>[vers l'avant]</A>\n";  &endoc;}#######################################################################  The "Simple" Lookup Subroutine#  This subroutine takes the input and checks to see if it is in #  one of the files of constants.  It returns a general description#  of that number (if it finds a match) and gives the specific#  function that could have produced the input.##  Notes:#  * To change the number of returns the program allows, change#  the variable $returns, found below######################################################################sub simple_look {  my($x) = @_;  my($integer) = 0;  my($returns) = 100;  my($prefix) = "$root?lookup_type=browse&page_no=";  my($l1) = "onMouseOver=\"window.status='Feuilleter autour... ";  my($l3) = "'; return true\"";#### Verify and clean input  $x = &clean_input($x);  &verify($x);  if (index($x,".") == -1) {    $integer = 1;    $cc = $x;    &verify_length($cc, 4);  } else {    $cc = &remove_decimal($x);    $cc = &clean_input($cc);    $cc = substr($cc, 0, 16);    &rational_check($cc);    &verify_length($cc, 5);  }#### Look up entries  if ($integer == 1) {    @index = &lookPIn($cc);  } else {    @index = &lookPI($cc);  }  $indexlength = $#index + 1;  &write_log("simple", $x, $indexlength);#### Begin writing the HTML output file#### Check to make sure we don't have too many returns  if ($indexlength > $returns) {    print "Number of values search returned:  $indexlength\n";;    print "</PRE><IMG SRC = /pi/work.gif>\n";    print "<FONT SIZE=5><B>Votre recherche trouve trop de cas.";    print "</B></FONT>\n";     print "<P><B>On lance le feuilleteur...</B></P>\n";    print "<HR SIZE=5><PRE>";    $page=0;    &browse($x);    &endoc;  }#### If search brings back none...  if ($indexlength <= 0) {      print "</PRE><IMG SRC =/pi/work.gif>\n";    print "<FONT SIZE=5><B>Votre recherche ne retourne rien.";    print "</B></FONT><BR><BR>\n";    print "\t<B>On lance le feuilleteur...</B>\n";    print "<HR SIZE=5><PRE>";    $page=0;    &browse($x);    &endoc;  }#### Sort the output, from simple to complex (sort on the R-code)  @sorted = sort {length(@$a[2]) <=> length(@$b[2])} @index;#### Output the result  print "\n\tVotre nombre $x a &eacute;t&eacute; g&eacute;n&eacute;r&eacute; par l'une\n";  print "\tdes fonctions ou trouv&eacute; dans l'une des tables suivantes.\n";  print "\tLes r&eacute;ponses sont donn&eacute;es par ordre de taille.\n";  for (@sorted) {    ($value, $rcode, $descr) = @$_;    if ($integer == 1) {      $rdescr = $iindex{$rcode};    } else {      $rdescr = $rindex{$rcode};    }    print "\n<B>$rdescr</B>";    print "<FONT COLOR=D000D0><B>".          substr($value,0,length($cc))."</B></FONT>".          substr($value,length($cc))." = $descr\n";  }  $page = 0;  print "</PRE><H3><A HREF=$prefix$page&number=$x $l1$x$l3>Feuilleter</A>";  print " autour $x.\n<PRE>";  &endoc;}#######################  Helpful subroutines  ############################################################################################## title_string -- returns a string containing the title of the HTML doc######################################################################sub title_string {  my($type, $value, $page_no) = @_;  my($out);  if ($type eq "browse") {    $out = "Browsing ";  } elsif ($type eq "simple") {    $out = "Simple Lookup: ";  } else {    $out = "Results: ";  }  $out .= &clean_input($value);	if ($type eq "browse") {	  $out .= " (Page $page_no)";	}	$out;}####################################################################### endoc --  a subroutine for the presenting the end of the page.#  It includes all the pictures and buttons to go back to other pages######################################################################sub endoc {  my($sec, $min, $hour, $mday, $mon, $year, $yday, $isdst) = localtime;  $mon ++; $year += 1900;  print "<P>";  print "</PRE><HR SIZE = 3>";  print "<A HREF = http://www.lacim.uqam.ca/pi/indexf.html>\n";  print "<IMG SRC =/pi/left.gif\n";  print " ALT=\"[Check Another Number]\"></a>\n";  print "<HR SIZE = 3><ADDRESS><A HREF = mailto:plouffe\@math.uqam.ca>\n";  print "plouffe\@math.uqam.ca</A></ADDRESS>\n";  print "</BODY>\n";  print "<!-- GŽnŽrŽ par PI $version [$mon/$mday/$year] /  -->\n";  print "</HTML>\n";  exit(0);}####################################################################### clean_input -- takes a string and removes null characters and#       leading zeros######################################################################sub clean_input {  my($ci) = @_;  $ci =~ s/^\s+|\s+$//g;  $ci =~ s/^0+//g;  $ci;}####################################################################### is_float -- returns 1 if the string contains only whitespace, digits,#               and decimal points#             returns 0 otherwise######################################################################sub is_float {  my($ci) = @_;  my($d);  while($ci ne "") {    $d = chop($ci);    if (($d ne " ") && ($d ne ".") && (($d lt "0") || ($d gt "9"))) {      return 0;    }  }  1;}####################################################################### is_passable -- returns 1 if the string contains only whitespace, digits,#                 decimal points, negative signs, and "e"#                returns 0 otherwise######################################################################sub is_passable {  $_[0] =~ /\s|\.|-|e|\d/i;}####################################################################### remove_decimal -- takes a string and removes the decimal from it and#  returns the string######################################################################sub remove_decimal {  my($ci) = @_;    $ci =~ s/\.//;  $ci;}####################################################################### rational_check -- takes the edited string, and verifies that it is not#  a rational number by checking a file containing rational numbers.#  Quits the program if there is a match######################################################################sub rational_check {  my($rc) = @_;  open (RATIONAL, "/plouffe/IP/rationallist")     || die "\nCouldn't open rational file..: $?";  while (<RATIONAL>) {    if ($rc eq $_) {      print "</PRE><H2>Votre nombre est un rationnel</H2><PRE>\n";      print "S.V.P entrez une nouvelle valeur.\n";      &endoc;    }  }  close (RATIONAL);}####################################################################### verify -- makes sure that the input is a a legal input.  If the input#   contains any non-numerical characters, or more than one decimal#  point, it will quit the program.  It will also check to see#  if the input has a decimal input######################################################################sub verify {  my($ci) = @_;  my($di) = remove_decimal($ci);  my($tt1, $pp1);  if (index($di,"e") != -1) {    $di = substr($di,0,index($di,"e"));  }  if (($ci eq "") || ($di =~ /\D/)) {    print "\n</PRE><H3>Erreur:</H3><PRE>";    print "\n\tVotre valeur n'est pas conforme.\n";    print "\tS.V.P entrez une nouvelle valeur.\n\n";    &endoc;  }}####################################################################### verify_length -- checks to see if the input has enough digits.  If#  not, the program will quit######################################################################sub verify_length {  my($y, $numberdigits) = @_;  if (length($y) < $numberdigits) {    print "\n</PRE><H3>Erreur:</H3><PRE>\n";    print "\tVous devez entrer $numberdigits d&eacute;cimales au moins.\n";    &endoc;  }}####################################################################### zpad -- adds a zero to the front of the string if its length is 1######################################################################sub zpad {  if (length($_[0]) == 1) {      $_[0] = "0".$_[0];  }}####################################################################### write_log -- writes to the appropriate log file######################################################################sub write_log {  my($name, $value, $hits) = @_;  my($sec, $min, $hour, $mday, $mon, $year, $yday, $isdst) = localtime;  $mon ++; $year += 1900;  $year = substr($year, 2, 2);  &zpad($mday);  &zpad($mon);  &zpad($hour);  &zpad($min);  &zpad($sec);  my($log) = join "", "/opt/etc/httpd/logs/logfile.", $year, $mon;  my($out) = join "", $year, $mon, $mday, $hour, $min, $sec;  $out .= ", $name, $value, $hits\n";  open(LOG, ">>$log") || die "Couldn't open log file $log.";  print LOG $out;  close(LOG);}